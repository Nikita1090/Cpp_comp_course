#include <iostream>

using namespace std; // это думаю известно что
// в с++ у нас есть классы у них как правило есть несколько конструкторов
// конструктор эта функция которая задаёт значения класса при создании, инициализирует крч
// деструктор это функ что удаляет класс при необходимости(в конце выполнения удаляются сами)
// есть ещё operator= и ему подобные. Они по сути заменяют указанную операцию на твой код
// есть поля и функ. с припиской static. Они не хранятся в классе, а общие для всех экземпляров.
// тоесть есть поле которое как отдельная глобальная переменная и такие же функции, которые с ними работают
// поля в классе по умолчанию я private

//идея решения задачи:
/*
определяем поле static A* pointer_for_obj в котором будем хранить ссылку на объект экземпляра
создаём функцию, которая при обращении создаёт объект этого класса внутри себя через new и возвращаем его
потом добавим условие, что если объект уже создан, то возвращаем ссылку на него.
про конструктор копирования  A(const A& c){a = c.a;};  забудь, нет разницы открыт или закрыт
*/
class A
{
    static A* pointer_for_obj; // храним ссылку на объект, единственный, нужен для работы со статическим методом
    int a; // just data, nothing more
    A(int i = 0):a(i){};
    A(const A& c){a = c.a;}; //если его открыть, ничего не поменяется
public:
    static A* getpointer(int i = 0) 
    {
        if (pointer_for_obj == nullptr) // чтобы только 1 раз создавать объект
        {
            pointer_for_obj = new A(i);
        }
        return pointer_for_obj;
    }
    int get_a() const 
    {
        return a;
    }
    ~A(){}; //он не вызывается
    static void del() // удаление объекта
    {
        delete pointer_for_obj;
    }
};

A* A::pointer_for_obj = nullptr; // задаём начальное значение В ГЛОБАЛЬНОЙ ОБЛАСТИ ВИДИМОСТИ(так обязательно надо)

int main() 
{
    A* obj1 = A::getpointer(5); // создаём экземпляр с а = 5
    cout << "Obj1 " << obj1->get_a() << endl;
    A* obj2 = A::getpointer(10); // создаём экземпляр с а = 10? но нет с 5 останется тот же самый
    cout << "Obj2 " << obj2->get_a() << endl;
    cout << "Obj1, after create Obj2 " << obj1->get_a() << endl;
    A::del();
    return 0;
}